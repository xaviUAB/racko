<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rack-O Game: Multijugador.</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclou les icones Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f3e8; }
        .card-slot {
            width: 100%;
            height: 60px;
            background-color: #e5e7eb;
            border: 2px dashed #9ca3af;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            font-weight: 700;
            border-radius: 8px;
            transition: all 0.2s;
            cursor: pointer;
            user-select: none;
        }
        .card-value {
            width: 90%;
            height: 90%;
            background-color: #ffffff;
            border: 3px solid #1f2937;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            color: #1f2937;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }
        .card-back {
            background-color: #4f46e5;
            border: 3px solid #fcd34d;
            color: white;
        }
        .card-slot:hover:not(.has-card, .not-playable) {
            background-color: #fca5a5;
            border-color: #ef4444;
        }
        .can-replace {
            box-shadow: 0 0 0 4px #10b981; /* Ring verd per a reemplaçar */
        }
        .can-replace:hover {
            transform: scale(1.02);
        }
        .current-player {
            box-shadow: 0 0 0 3px #f59e0b;
        }
        
        /* Estils per la carta-cursor */
        #floating-card {
            position: fixed;
            pointer-events: none; /* Important per permetre el clic sota el cursor */
            z-index: 1000;
            width: 50px;
            height: 70px;
            transform: translate(-50%, -50%); /* Centrar la carta sota el cursor */
            opacity: 0;
            transition: opacity 0.1s;
        }
        #floating-card.active {
            opacity: 1;
        }
        #floating-card .card-value {
            width: 100%;
            height: 100%;
            font-size: 1.5rem;
            line-height: 1;
        }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "firebase/": "https://aistudiocdn.com/firebase@^12.5.0/",
    "lucide-react": "https://aistudiocdn.com/lucide-react@^0.552.0"
  }
}
</script>
</head>
<body class="p-4 sm:p-6">

    <!-- Carta flotant (substitut de cursor) -->
    <div id="floating-card">
        <div class="card-value shadow-2xl"></div>
    </div>
    
    <!-- UI DEL JOC -->
    <div class="max-w-4xl mx-auto p-4 bg-white rounded-xl shadow-2xl">
        
        <!-- Header i Estat -->
        <header class="mb-4 flex flex-col sm:flex-row justify-between items-center pb-4 border-b">
            <h1 class="text-3xl font-extrabold text-gray-900 mb-2 sm:mb-0">Rack-O <span class="text-indigo-600 text-base">v. Multiplayer</span></h1>
            <div id="game-status" class="text-sm font-semibold">Carregant...</div>
        </header>

        <!-- DEBUG & DIAGNÒSTIC (Ajudar a l'usuari a comprovar la connexió) -->
        <div id="debug-and-host-tools" class="text-xs p-2 mb-4 bg-yellow-50 rounded-lg border border-yellow-200 flex flex-col sm:flex-row justify-between items-center">
            <div class="mb-2 sm:mb-0">
                <h4 class="font-bold text-yellow-800 mb-1">Panell de Diagnòstic (Debug)</h4>
                <span id="user-id-display" class="block text-gray-600">ID d'Usuari: <span class="font-mono text-xs">Carregant...</span></span>
                <span id="game-id-display" class="block text-gray-600">ID de Partida Activa: <span id="game-id-value" class="font-bold text-red-600">N/A</span></span>
            </div>
            <!-- Botó de Reinici de l'Amfitrió -->
            <div id="host-reset-area" class="mt-2 sm:mt-0 w-full sm:w-auto"></div>
        </div>
        <!-- Fi de DEBUG & DIAGNÒSTIC -->

        <!-- Àrea Principal de l'Aplicació (Lobby o Joc) -->
        <div id="main-container">
            <div id="game-container" class="mt-4">
                <!-- El contingut del lobby o joc es renderitzarà aquí -->
                <p class="text-center text-gray-600">Carregant l'estat de la partida...</p>
            </div>
            
            <!-- Àrea de Joc Activa -->
            <div id="game-active-area" class="mt-6 hidden">

                <!-- Zones de Munt i Descart -->
                <div class="flex justify-center space-x-8 mb-6 p-4 bg-gray-50 rounded-lg shadow-inner">
                    
                    <div class="flex flex-col items-center">
                        <h4 class="font-bold text-gray-700 mb-2 flex items-center">
                            <i data-lucide="layers" class="w-4 h-4 mr-1"></i> Munt (<span id="draw-pile-count">0</span>)
                        </h4>
                        <!-- El contenidor del munt, el contingut i l'acció es defineixen dinàmicament al JS -->
                        <div id="draw-pile" class="w-20 h-32 border-4 border-gray-400 rounded-lg cursor-pointer transition duration-200">
                            <!-- Carta coberta / Botó de Barrejar / Buit -->
                        </div>
                    </div>
                    
                    <div class="flex flex-col items-center">
                        <h4 class="font-bold text-gray-700 mb-2 flex items-center">
                            <i data-lucide="trash-2" class="w-4 h-4 mr-1"></i> Descarts
                        </h4>
                        <div id="discard-pile" class="w-20 h-32 border-4 border-gray-400 rounded-lg">
                            <!-- Carta visible -->
                        </div>
                    </div>

                </div>
                
                <!-- Missatge/Acció de Torn -->
                <div id="action-area" class="mb-6 p-3 rounded-xl text-center">
                    <!-- Botó de 'Començar Partida' o missatge de torn -->
                </div>

                <!-- El teu Atril (Rack) -->
                <div class="bg-indigo-50 p-4 rounded-xl shadow-inner mb-2">
                    <h3 class="text-xl font-bold text-indigo-700 mb-3">El Teu Atril (Rack)</h3>
                    <div id="my-rack" class="grid grid-flow-col grid-rows-5 grid-cols-2 sm:grid-flow-row sm:grid-cols-5 gap-3">
                        <!-- Les 10 ranures de l'atril es renderitzaran aquí -->
                    </div>
                </div>

                <!-- Puntuacions i Altres Jugadors -->
                <h3 class="text-xl font-bold text-gray-700 mb-3">Puntuació Global</h3>
                <div id="all-players-score" class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                    <!-- Puntuacions de tots els jugadors -->
                </div>

            </div>
        </div>
    </div>

    <!-- Modal Personalitzat (substitut d'alert/confirm) -->
    <div id="custom-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 transition-opacity duration-300">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h4 id="modal-title" class="text-2xl font-bold mb-3 text-red-600">Títol del Modal</h4>
            <p id="modal-message" class="text-gray-700 mb-4">Missatge del modal.</p>
            <div id="modal-actions" class="flex flex-col space-y-2">
                <button id="modal-confirm-btn" class="hidden w-full py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition duration-200">
                    Confirmar
                </button>
                <button id="modal-close-btn" onclick="window.gameFunctions.closeModal()" class="w-full py-2 bg-indigo-500 text-white font-semibold rounded-lg hover:bg-indigo-700 transition duration-200">
                    Entès
                </button>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs - MOGUT AL FINAL DEL BODY PER GARANTIR QUE ELS ELEMENTS HTML ES CARREGUIN ABANS -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, updateDoc, arrayRemove, arrayUnion, runTransaction, getDocs, where, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        /** * ===============================================================================
         * Configuració Manual de Firebase per a Execució Fora de Canvas (com GitHub Pages)
         * ===============================================================================
         * Quan utilitzis aquest codi fora de l'entorn Canvas (p. ex., GitHub Pages), 
         * NECESSITES substituir l'objecte FIREBASE_SETTINGS a continuació per la teva
         * configuració real de Firebase. AQUESTA CONFIGURACIÓ HA ESTAT AFEGIDA PER L'USUARI.
         */
        const FIREBASE_SETTINGS = { 
            apiKey: "AIzaSyDQWCvBru356guXE3tAB6R2VjOsqaFHttY",
            authDomain: "rack-o-16931.firebaseapp.com",
            projectId: "rack-o-16931",
            storageBucket: "rack-o-16931.firebasestorage.app",
            messagingSenderId: "127219641303",
            appId: "1:127219641303:web:285e63d0bfecb9da4db992",
            measurementId: "G-1EQ8RBNL1J"
        }; 
        const MANUAL_APP_ID_FOR_PATH = "rack-o-16931"; // Utilitza Project ID com a fallback per la ruta /artifacts/{appId}/public/...


        // Configuració de Firebase i variables globals (Prioritza Canvas, sinó usa MANUAL)
        const isCanvasEnvironment = typeof __firebase_config !== 'undefined';
        
        const appId = isCanvasEnvironment ? (typeof __app_id !== 'undefined' ? __app_id : 'default-app-id') : MANUAL_APP_ID_FOR_PATH;
        
        const firebaseConfig = isCanvasEnvironment ? 
            JSON.parse(__firebase_config) : 
            FIREBASE_SETTINGS;
            
        const initialAuthToken = isCanvasEnvironment ? (typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null) : null;

        let app, db, auth;
        let userId = null;
        let gameId = null;
        let gameState = null;
        let unsubscribeGame = null;
        let syncErrorCount = 0; 

        // Estats de joc del client
        let heldCard = null; 
        let heldSource = null; 
        
        // NOU: Bloqueig per evitar la doble execució de l'acció de robar carta (Causa del bug)
        let isDrawingCard = false; 
        
        // Constants de Joc
        const CARD_DECK_SIZES = { 2: 40, 3: 50, 4: 60 };
        const NUM_CARDS_IN_RACK = 10;
        const RACKO_POINTS = 75;
        const INACTIVITY_TIMEOUT_MS = 5 * 60 * 1000; // 5 minuts = 300,000 ms

        // Funció per calcular el color de fons d'una carta (de blanc a vainilla)
        const getCardBackgroundColor = (cardValue, maxCardValue) => {
            if (cardValue === null || !maxCardValue || maxCardValue <= 1) {
                return 'background-color: #ffffff;'; // Blanc per defecte
            }
            // Normalitza el valor entre 0 i 1
            const ratio = (cardValue - 1) / (maxCardValue - 1);

            // Color inicial: blanc (r=255, g=255, b=255)
            const r1 = 255, g1 = 255, b1 = 255;
            // Color final: "vainilla" intensificat #FAEEC4 (r=250, g=238, b=196)
            const r2 = 250, g2 = 238, b2 = 196;

            // Interpolació lineal
            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);

            return `background-color: rgb(${r}, ${g}, ${b});`;
        };

        // Referència al component de la carta flotant (cursor)
        const floatingCardElement = document.getElementById('floating-card');
        const floatingCardValueElement = floatingCardElement.querySelector('.card-value');

        // GESTIÓ DE SO I VIBRACIÓ
        let audioContext;
        let lastTurnProcessed = null; 
        let lastWinProcessed = null; 

        const initAudio = () => {
            if (!audioContext) {
                 try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn("Web Audio API no suportada. Els sons estaran desactivats.", e);
                }
            }
        };

        const playBeep = () => {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'square'; 
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime); 
            gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.3);
        };

        const playWinMelody = () => {
            if (!audioContext) return;
            const tempo = 120; 
            const quarterNote = 60 / tempo; 

            const melody = [
                { freq: 660, duration: quarterNote * 0.5 }, 
                { freq: 784, duration: quarterNote * 0.5 },
                { freq: 988, duration: quarterNote * 1.5 } 
            ];

            let time = audioContext.currentTime;

            melody.forEach(note => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(note.freq, time); 
                gainNode.gain.setValueAtTime(0.3, time);

                gainNode.gain.linearRampToValueAtTime(0.1, time + 0.01);
                gainNode.gain.linearRampToValueAtTime(0.001, time + note.duration);

                oscillator.start(time);
                oscillator.stop(time + note.duration);

                time += note.duration; 
            });
        };

        const vibrate = (pattern = [200]) => {
            if ('vibrate' in navigator) {
                navigator.vibrate(pattern);
            }
        };
        // FI DE GESTIÓ DE SO I VIBRACIÓ


        // Escolta el moviment del ratolí per la carta flotant
        document.addEventListener('mousemove', (e) => {
            if (heldCard) {
                floatingCardElement.style.left = `${e.clientX}px`;
                floatingCardElement.style.top = `${e.clientY}px`;
            }
        });


        // Funció per generar un ID de 4 dígits (1000-9999)
        const generate4DigitId = () => {
            return String(Math.floor(1000 + Math.random() * 9000));
        };


        // Inicialització de Firebase
        const initFirebase = async () => {
            if (Object.keys(firebaseConfig).length === 0 && !isCanvasEnvironment) {
                console.error("Firebase config is missing. Please set FIREBASE_SETTINGS for GitHub execution.");
                document.getElementById('main-container').innerHTML = `<p class="text-red-600">Error: La configuració de Firebase no està disponible. Si ho executes des de GitHub, has d'establir la variable FIREBASE_SETTINGS al codi font amb la teva clau.</p>`;
                return;
            }
            try {
                // setLogLevel('debug'); // Uncomment to see detailed Firestore logs
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Authentication
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        // UPDATE DEBUG PANEL: Show User ID
                        document.getElementById('user-id-display').innerHTML = `ID d'Usuari: <span class="font-mono text-xs">${userId}</span>`;
                        console.log(`[AUTH] User ID set: ${userId}. Attempting to load last game...`);
                        loadLastGame();
                    } else {
                        // Lògica d'autenticació adaptada per a Canvas vs GitHub
                        if (isCanvasEnvironment && initialAuthToken) {
                            // Entorn Canvas: Usa el token personalitzat
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            // Entorn GitHub/Altres: Usa l'autenticació anònima
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Error inicialitzant Firebase:", error);
                document.getElementById('main-container').innerHTML = `<p class="text-red-600">Error en la inicialització de l'aplicació. (Comprova la configuració de FIREBASE_SETTINGS si no ets a Canvas).</p>`;
            }
        };

        // --- FUNCIONS CORE DE JOC ---
        const createAndShuffleDeck = (maxCard) => {
            let newDeck = Array.from({ length: maxCard }, (_, i) => i + 1);
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        };

        // Funció per barrejar un array existent (Fisher-Yates)
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        const checkAscendingOrder = (rack) => {
            if (rack.length !== NUM_CARDS_IN_RACK || rack.includes(null)) return false;
            for (let i = 0; i < rack.length - 1; i++) {
                if (rack[i] >= rack[i + 1]) {
                    return false;
                }
            }
            return true;
        };

        const checkForConsecutiveSequence = (rack) => {
            for (let i = 0; i <= rack.length - 3; i++) {
                if (rack[i] + 1 === rack[i + 1] && rack[i + 1] + 1 === rack[i + 2]) {
                    return true; 
                }
            }
            return false;
        };

        const checkVictoryCondition = (game, playerRack) => {
            const isAscending = checkAscendingOrder(playerRack);
            if (!isAscending) return false;
            if (game.numPlayers > 2) {
                return true;
            }
            // Regla de 2 jugadors: Han de tenir una seqüència de 3 per guanyar amb un Rack-O
            if (game.numPlayers === 2) {
                return checkForConsecutiveSequence(playerRack);
            }
            return false; 
        };

        const calculateSequenceScore = (rack) => {
            const SEQUENCE_POINTS_PER_CARD = 5;
            let score = 0;
            if (rack.length !== NUM_CARDS_IN_RACK || rack.includes(null)) return 0;
            
            // Rack-O tradicional: 5 punts per cada carta que estigui en ordre ascendent respecte a la carta anterior.
            for (let i = 0; i < rack.length; i++) {
                if (i === 0 || rack[i] > rack[i - 1]) {
                    score += SEQUENCE_POINTS_PER_CARD;
                } else {
                    break;
                }
            }
            // En un Rack-O perfecte (ordre ascendent complet), la puntuació seria 50 (10*5).
            return score;
        };
        
        // Funció per calcular el bonus per seqüències (runs)
        const calculateRunBonus = (rack) => {
            if (!rack || rack.length !== NUM_CARDS_IN_RACK || rack.includes(null)) return 0;
            
            let longestRun = 0;
            let currentRun = 1;
            for (let i = 1; i < rack.length; i++) {
                if (rack[i] === rack[i - 1] + 1) {
                    currentRun++;
                } else {
                    longestRun = Math.max(longestRun, currentRun);
                    currentRun = 1;
                }
            }
            longestRun = Math.max(longestRun, currentRun); // Comprova la darrera seqüència

            if (longestRun >= 6) return 400;
            if (longestRun === 5) return 200;
            if (longestRun === 4) return 100;
            if (longestRun === 3) return 50;
            return 0;
        };
        // --- FI DE FUNCIONS CORE DE JOC ---


        // --- FIREBASE I GESTIÓ DE PARTIDES ---

        const getGameRef = (gameId) => doc(db, 'artifacts', appId, 'public', 'data', 'racko_games', gameId);

        const deleteGameAndReset = async (isManual = false) => {
            if (!gameId) return;

            const currentId = gameId; // Capture ID before state reset
            
            // 1. Unsubscribe first to stop listening
            if (unsubscribeGame) {
                unsubscribeGame();
                unsubscribeGame = null;
            }

            try {
                console.log(`[RESET] Deleting game document ${currentId}.`);
                // 2. Delete the Firestore document (only if it still exists to avoid unnecessary errors)
                await deleteDoc(getGameRef(currentId)); 

                // 3. Reset local state
                resetLobbyState(isManual ? 
                    "La partida ha estat reiniciada correctament per l'amfitrió." : 
                    "La partida ha estat reiniciada automàticament per inactivitat (5 minuts)."
                );
            } catch (error) {
                console.warn("Error eliminant el document de la partida. Suposant que ja ha estat eliminat per un altre client o per regles de seguretat.", error);
                // Fallback: just reset local state if deletion fails (e.g., permission issues)
                resetLobbyState(isManual ? 
                    "La partida ha estat reiniciada correctament per l'amfitrió." : 
                    "La partida ha estat reiniciada automàticament per inactivitat (5 minuts)."
                );
            }
        };

        const loadLastGame = async () => {
            if (!userId || gameId) return; 

            // Search for an active game where the user is a participant
            const q = query(
                collection(db, 'artifacts', appId, 'public', 'data', 'racko_games'),
                where('playerIds', 'array-contains', userId) 
            );
            
            try {
                const snapshot = await getDocs(q);
                if (!snapshot.empty) {
                    gameId = snapshot.docs[0].id;
                    console.log(`[LOAD] Reconnecting to existing game ID: ${gameId}`);
                    startListeningToGame(gameId);
                } else {
                    console.log("[LOAD] No active game found for this user. Rendering lobby.");
                    renderLobby();
                }
            } catch (error) {
                console.error("Error carregant l'última partida (REQUEREIX REVISIÓ DE REGLES):", error);
                renderLobby("Error carregant l'última partida. (Problema de Permisos/Connexió). Intenta crear-ne una de nova.");
            }
        };

        const startListeningToGame = (id) => {
            if (unsubscribeGame) unsubscribeGame();
            gameId = id;
            document.getElementById('game-id-value').textContent = gameId; // Update debug panel immediately

            unsubscribeGame = onSnapshot(getGameRef(gameId), (doc) => {
                if (doc.exists()) {
                    gameState = doc.data();
                    
                    // === NOU: Detecció d'inactivitat ===
                    const lastUpdate = gameState.lastUpdate || 0;
                    const timeElapsed = Date.now() - lastUpdate;

                    if (timeElapsed > INACTIVITY_TIMEOUT_MS) {
                        console.log(`[INACTIVITY] Game ${gameId} inactive for ${Math.floor(timeElapsed / 1000)}s. Attempting to delete.`);
                        deleteGameAndReset(false); // Reinici automàtic
                        return; // Stop processing the snapshot, we are resetting
                    }
                    // === FI NOU ===

                    console.log(`[SNAPSHOT] Game state updated for ID: ${gameId}, Status: ${gameState.status}`);
                    renderGame(gameState);
                } else {
                    console.error(`[SNAPSHOT ERROR] Partida ${gameId} ja no existeix. Tornant al Lobby.`);
                    resetLobbyState("La partida ha estat eliminada del servidor (Firestore). Torna a crear o unir-te.");
                }
            }, (error) => {
                console.error("Error en onSnapshot (connexió perduda):", error);
                resetLobbyState("Error de connexió en temps real. Torna a intentar d'unir-te. (Revisa la teva connexió)");
            });
        };

        const resetLobbyState = (message = "L'estat de connexió s'ha netejat. Torna a unir-te o crea una nova partida.") => {
            console.log("[LOBBY] Reiniciant estat local.");
            if (unsubscribeGame) {
                unsubscribeGame();
                unsubscribeGame = null;
            }
            gameId = null;
            gameState = null;
            heldCard = null;
            heldSource = null;
            floatingCardElement.classList.remove('active');
            document.getElementById('game-id-value').textContent = 'N/A'; // Clear debug panel
            // Reinicia els controls de so/vibració
            lastTurnProcessed = null;
            lastWinProcessed = null;
            renderLobby(message);
        };

        const validatePlayerName = (name) => {
            const trimmedName = name.trim();
            if (trimmedName.length < 2 || trimmedName.length > 15) {
                showModal("Error de Nom", "Introdueix un nom vàlid d'entre 2 i 15 caràcters.");
                return null;
            }
            localStorage.setItem('racko_player_name', trimmedName); // Save on success
            return trimmedName;
        }

        const createGame = async (numPlayers, rawPlayerName) => {
            // Inicialitza l'àudio amb la primera interacció (necessari per al navegador)
            initAudio(); 
            
            const createButton = event.currentTarget;
            const originalText = createButton.innerHTML;
            
            const playerName = validatePlayerName(rawPlayerName);
            if (!playerName || numPlayers < 2 || numPlayers > 4) return;
            
            createButton.disabled = true;
            createButton.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 mr-2 animate-spin"></i> Creant...`;
            lucide.createIcons();
            
            let uniqueId = null;
            let maxRetries = 10;
            for (let i = 0; i < maxRetries; i++) {
                const potentialId = generate4DigitId();
                const gameRef = getGameRef(potentialId);
                const docSnap = await getDoc(gameRef);

                if (!docSnap.exists()) {
                    uniqueId = potentialId;
                    break;
                }
            }

            if (!uniqueId) {
                showModal("Error", "No s'ha pogut generar una ID única de 4 dígits. Torna a intentar-ho.");
                createButton.disabled = false;
                createButton.innerHTML = originalText;
                return;
            }

            const maxCardValue = CARD_DECK_SIZES[numPlayers];
            const fullDeck = createAndShuffleDeck(maxCardValue);
            
            const newPlayer = {
                id: userId,
                name: playerName, 
                rack: Array(NUM_CARDS_IN_RACK).fill(null), 
                score: 0,
                scoreHistory: []
            };

            const newGameData = {
                status: 'lobby',
                numPlayers: numPlayers,
                maxCardValue: maxCardValue,
                playerIds: [userId],
                players: [newPlayer],
                deck: fullDeck,
                discardPile: [],
                turn: null, 
                messages: [`${newPlayer.name} ha creat la partida.`],
                lastUpdate: Date.now(), // Timestamp inicial per inactivitat
                beepTrigger: null 
            };

            try {
                const newGameRef = getGameRef(uniqueId);
                await setDoc(newGameRef, newGameData);
                console.log(`[CREATE] Partida ${uniqueId} creada amb èxit.`);
                startListeningToGame(uniqueId);
            } catch (error) {
                console.error("Error creant la partida (REQUEREIX REVISIÓ DE REGLES):", error);
                showModal("Error", "No s'ha pogut crear la partida. Assegura't de tenir connexió a internet i que les regles de seguretat ho permetin.");
                resetLobbyState();
            } finally {
                if (!gameId) {
                     createButton.disabled = false;
                     createButton.innerHTML = originalText;
                }
            }
        };

        const joinGame = async (gameIdToJoin, rawPlayerName) => {
            // Inicialitza l'àudio amb la primera interacció (necessari per al navegador)
            initAudio(); 
            
            const joinButton = document.getElementById('join-button');
            
            const playerName = validatePlayerName(rawPlayerName);
            const trimmedId = gameIdToJoin.trim();
            if (!playerName || !trimmedId || trimmedId.length !== 4 || isNaN(trimmedId)) {
                if (playerName) showModal("Error", "Introdueix una ID de partida vàlida de 4 dígits.");
                return;
            }
            
            joinButton.disabled = true;
            joinButton.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 mr-2 animate-spin"></i> Carregant...`;
            lucide.createIcons(); 

            const gameRef = getGameRef(trimmedId);

            try {
                const gameDoc = await getDoc(gameRef);
                
                if (!gameDoc.exists()) throw new Error("La partida no existeix (Codi incorrecte)."); 

                const game = gameDoc.data();
                
                if (game.playerIds.includes(userId)) {
                    startListeningToGame(trimmedId);
                    return; 
                }

                await runTransaction(db, async (transaction) => {
                    const gameDocInTx = await transaction.get(gameRef);
                    const gameInTx = gameDocInTx.data(); 
                    
                    if (gameInTx.status !== 'lobby') throw new Error("La partida ja ha començat.");
                    if (gameInTx.playerIds.length >= gameInTx.numPlayers) throw new Error("La partida està plena.");
                    
                    const newPlayer = {
                        id: userId,
                        name: playerName, 
                        rack: Array(NUM_CARDS_IN_RACK).fill(null),
                        score: 0,
                        scoreHistory: []
                    };
                    
                    if (gameInTx.players.some(p => p.name.toLowerCase() === playerName.toLowerCase())) {
                        throw new Error("Aquest nom ja està en ús en aquesta partida.");
                    }

                    const updatedPlayers = [...gameInTx.players, newPlayer];

                    transaction.update(gameRef, {
                        playerIds: arrayUnion(userId),
                        players: updatedPlayers,
                        messages: arrayUnion(`${newPlayer.name} s'ha unit.`),
                        lastUpdate: Date.now()
                    });
                });
                
                startListeningToGame(trimmedId);

            } catch (error) {
                console.error("[!!! REQUERIT PER AL DIAGNÒSTIC !!!] Error unint-se a la partida:", error);
                let msg = error.message.includes("document does not exist") ? "La partida no existeix (Codi incorrecte)." : error.message;
                if (error.code === 'permission-denied' || error.message.includes('permissions')) {
                     msg = "Permisos Insuficients: Assegura't que has publicat les regles de seguretat més recents a Firebase!";
                }
                showModal("Error d'Unió", `No s'ha pogut unir a la partida: ${msg}.`);
                resetLobbyState();
            } finally {
                if (!gameId) { 
                    joinButton.disabled = false;
                    joinButton.innerHTML = `Unir-se`;
                }
            }
        };

        const startGame = async () => {
            if (!gameState || gameState.status !== 'lobby' || gameState.playerIds.length < 2) {
                 // Aquesta validació utilitza l'estat local per a feedback ràpid
                 if (gameState && gameState.status === 'lobby' && gameState.playerIds.length < 2) {
                    showModal("❌ Partida Incompleta", "Necessites almenys 2 jugadors per començar.");
                 }
                 return;
            }
            
            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);

                    if (!gameDoc.exists() || gameDoc.data().status !== 'lobby') {
                        throw new Error("Estat de partida invàlid o ja iniciada.");
                    }

                    const game = gameDoc.data();
                    
                    // VALIDACIÓ CLAU ATÒMICA: Assegurar-se que el nombre de jugadors és correcte
                    if (game.players.length !== game.numPlayers) {
                         // Llença un error per forçar el rollback de la transacció
                         throw new Error(`Partida incompleta. Falten ${game.numPlayers - game.players.length} jugadors.`);
                    }

                    let fullDeck = createAndShuffleDeck(game.maxCardValue); 
                    let players = game.players;

                    let newRacks = Array.from({ length: players.length }, () => Array(NUM_CARDS_IN_RACK).fill(null));

                    for (let i = NUM_CARDS_IN_RACK - 1; i >= 0; i--) { 
                        for (let j = 0; j < players.length; j++) {
                            const card = fullDeck.pop();
                            if (card !== undefined) {
                                newRacks[j][i] = card; 
                            }
                        }
                    }

                    players = players.map((p, index) => ({
                        ...p,
                        rack: newRacks[index]
                    }));

                    const firstDiscard = fullDeck.pop();
                    let discardPile = [];
                    if (firstDiscard !== undefined) {
                        discardPile.push(firstDiscard);
                    }
                    
                    const startingPlayerIndex = Math.floor(Math.random() * players.length);
                    const startingPlayerId = players[startingPlayerIndex].id;

                    transaction.update(gameRef, {
                        status: 'playing',
                        players: players, 
                        deck: fullDeck,
                        discardPile: discardPile,
                        turn: startingPlayerId,
                        messages: arrayUnion("La partida ha començat! Bona sort."),
                        lastUpdate: Date.now()
                    });
                    console.log(`[START GAME] Partida ${gameId} a 'playing'. Torn de ${startingPlayerId}.`);

                });
            } catch (error) {
                console.error("Error iniciant la partida:", error);
                
                // Si l'error és la nostra validació atòmica, mostrem un missatge més amigable
                if (error.message.includes('Partida incompleta')) {
                     showModal("❌ Partida Incompleta", `No s'ha pogut iniciar la partida. ${error.message}. Assegura't que TOTS els jugadors s'han unit.`);
                } else {
                    showModal("Error", `No s'ha pogut iniciar la partida: ${error.message}`);
                }
            }
        };
        
        // Funció per barrejar explícitament la pila de descartes
        const handleReshuffle = async () => {
            if (!isMyTurn() || gameState.deck.length !== 0) {
                // Aquesta comprovació hauria de ser redundant si el botó es renderitza correctament
                return showModal("❌ Acció Invàlida", "Només pots barrejar quan és el teu torn i el munt està buit.");
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data(); 

                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");
                    if (game.deck.length !== 0) throw new Error("El munt no està buit. No cal barrejar.");
                    if (game.discardPile.length <= 1) throw new Error("No queden suficients cartes per barrejar. Espera a que hi hagi més de una carta al descart.");
                    
                    // 1. Treure la carta superior del descart
                    const topDiscardCard = game.discardPile.pop();
                    let cardsToReshuffle = game.discardPile;
                    
                    // 2. Barrejar les cartes restants
                    const newDeck = shuffleArray(cardsToReshuffle);
                    const newDiscardPile = [topDiscardCard];

                    // 3. Actualitzar l'estat
                    transaction.update(gameRef, {
                        deck: newDeck,
                        discardPile: newDiscardPile,
                        messages: arrayUnion(`${getMyPlayer().name} ha barrejat la pila de descarts. El joc continua!`),
                        lastUpdate: Date.now()
                    });
                });
                
            } catch (error) {
                console.error("Error barrejant la pila de descarts:", error);
                showModal("Error de Barrejada", `No s'ha pogut barrejar la pila de descarts: ${error.message}`);
            }
        };


        const handleDrawCard = async (source) => {
            // NOU: Bloqueig d'execució per evitar la doble execució (causa del doble robatori)
            if (isDrawingCard) return;

            if (!isMyTurn() || heldCard) {
                if (!isMyTurn()) {
                    showModal("❌ Acció Invàlida", "No és el teu torn.");
                } else if (heldCard) {
                    showModal("❌ Acció Invàlida", "Ja tens una carta a la mà.");
                }
                return;
            }
            
            if (source === 'discard' && gameState.discardPile.length === 0) return showModal("❌ Descart Buida", "La pila de descarts està buida.");
            
            if (source === 'draw' && gameState.deck.length === 0) {
                 return showModal("❌ Munt Buit", "El munt està buit. Si us plau, clica el botó 'Barrejar Descartades' que ha d'aparèixer per continuar.");
            }

            // Bloqueja la funció
            isDrawingCard = true; 
            let cardValue = null;

            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data(); 
                    
                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");

                    if (source === 'draw') {
                        // Utilitzem slice per eliminar explícitament l'últim element, garantint una sola carta.
                        const deckLength = game.deck.length;
                        if (deckLength === 0) throw new Error("Baralla buida."); 
                        
                        cardValue = game.deck[deckLength - 1]; 
                        
                        game.deck = game.deck.slice(0, deckLength - 1); 
                    } else if (source === 'discard') {
                        cardValue = game.discardPile.pop();
                         if (cardValue === undefined) throw new Error("Descart buit.");
                    }

                    const updateData = {
                        deck: game.deck,
                        discardPile: game.discardPile,
                        lastUpdate: Date.now()
                    };
                    
                    transaction.update(gameRef, updateData);
                });
                
                // Actualització de l'estat local NOMÉS DESPRÉS de la transacció
                heldCard = cardValue;
                heldSource = source;
                // Actualitza la carta flotant immediatament per a la UI local
                const cardStyle = getCardBackgroundColor(heldCard, gameState.maxCardValue);
                floatingCardValueElement.setAttribute('style', cardStyle);
                floatingCardValueElement.textContent = heldCard;
                floatingCardElement.classList.add('active');


            } catch (error) {
                console.error("Error agafant la carta:", error);
                showModal("Error", `No s'ha pogut agafar la carta. Torna a intentar-ho: ${error.message}`);
                // Neteja l'estat local en cas d'error de transacció, ja que la BD no s'ha actualitzat
                heldCard = null;
                heldSource = null;
                floatingCardElement.classList.remove('active');
            } finally {
                // Allibera el bloqueig d'execució
                isDrawingCard = false; 
            }
        };

        /**
         * Funció per descartar la carta actualment a la mà.
         * Només es permet si la carta s'ha agafat del munt ('draw').
         */
        const handleDiscardHeldCard = async () => {
            if (!isMyTurn() || !heldCard) {
                return showModal("❌ Acció Invàlida", "Primer has d'agafar una carta.");
            }

            if (heldSource !== 'draw') {
                return showModal("❌ Acció Invàlida", "Si has agafat la carta del descart, has de reemplaçar una ranura.");
            }
            
            const cardToDiscard = heldCard;

            try {
                 await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();

                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");

                    game.discardPile.push(cardToDiscard);

                    const nextTurnId = getNextPlayerId(game);

                    transaction.update(gameRef, {
                        discardPile: game.discardPile,
                        turn: nextTurnId,
                        messages: arrayUnion(`${getMyPlayer().name} ha descartat la carta ${cardToDiscard}.`),
                        lastUpdate: Date.now() // Actualitza timestamp
                    });
                });
                
                heldCard = null;
                heldSource = null;
                floatingCardElement.classList.remove('active'); 

            } catch (error) {
                console.error("Error descartant la carta:", error);
                showModal("Error", "No s'ha pogut descartar la carta.");
            }
        };


        const handleReplaceCard = async (slotIndex) => {
            if (!isMyTurn() || !heldCard) return showModal("❌ Acció Invàlida", "Primer has d'agafar una carta.");
            
            const player = getMyPlayer();
            const cardToDiscard = player.rack[slotIndex];
            const newCard = heldCard;

            try {
                await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();

                    if (game.turn !== userId) throw new Error("Ja no és el teu torn.");
                    
                    const players = game.players;
                    const currentPlayerIndex = players.findIndex(p => p.id === userId);
                    if (currentPlayerIndex === -1) throw new Error("Jugador no trobat a la transacció.");
                    
                    const currentPlayer = players[currentPlayerIndex];

                    const newRack = [...currentPlayer.rack];
                    newRack[slotIndex] = newCard;

                    let status = game.status;
                    let winnerId = null;
                    let winMessage = '';

                    // Comprova si el nou rack compleix les condicions de victòria
                    if (checkVictoryCondition(game, newRack)) {
                        status = 'finished_hand';
                        winnerId = userId;
                        
                        if (game.numPlayers === 2) {
                            winMessage = `${currentPlayer.name} crida "Rack-O!" i guanya la mà complint la seqüència de 3!`;
                        } else {
                            winMessage = `${currentPlayer.name} crida "Rack-O!" i guanya la mà!`;
                        }
                        game.messages.push(winMessage);
                    }

                    // Actualitza el rack del jugador a la llista de jugadors
                    currentPlayer.rack = newRack;
                    
                    // Afegeix la carta reemplaçada a la pila de descarts
                    game.discardPile.push(cardToDiscard);

                    // Determina el següent torn (si la mà no ha acabat)
                    const nextTurnId = (status !== 'finished_hand') ? getNextPlayerId(game) : game.turn;

                    transaction.update(gameRef, {
                        players: players,
                        discardPile: game.discardPile,
                        turn: nextTurnId,
                        status: status,
                        winnerId: winnerId || game.winnerId || null,
                        messages: arrayUnion(`${currentPlayer.name} ha reemplaçat la ranura ${slotIndex + 1} (${cardToDiscard}) per la carta ${newCard}.`),
                        lastUpdate: Date.now() // Actualitza timestamp
                    });
                });
                
                heldCard = null;
                heldSource = null;
                floatingCardElement.classList.remove('active'); 

            } catch (error) {
                console.error("Error reemplaçant la carta:", error);
                showModal("Error", "No s'ha pogut reemplaçar la carta. Torna a intentar-ho.");
            }
        };

        const triggerRemoteBeep = async (targetId) => {
            if (!gameId || gameState.status !== 'playing') return showModal("❌ Acció Invàlida", "El joc no està en curs.");
            if (targetId !== gameState.turn) return showModal("❌ Acció Invàlida", "Això només funciona per a un jugador que no estigui al torn actual.");
            
            // Límita l'acció globalment per evitar abusos
            if (gameState.beepTrigger && (Date.now() - gameState.beepTrigger.timestamp < 5000)) {
                return showModal("⏳ Espera", "Si us plau, espera 5 segons abans de tornar a alertar el jugador.");
            }

            try {
                await updateDoc(getGameRef(gameId), {
                    beepTrigger: {
                        targetId: targetId,
                        timestamp: Date.now()
                    },
                    lastUpdate: Date.now() // Actualitza timestamp
                });
                console.log(`[BEEP] Beep trigger sent to ${targetId}`);
                showModal("Alerta Enviada", "S'ha enviat un 'beep' al dispositiu del jugador actiu.");
            } catch (error) {
                console.error("Error triggerant el beep remot:", error);
                showModal("Error de Beep", "No s'ha pogut enviar l'alerta de so.");
            }
        };


        const getNextPlayerId = (game) => {
            const playerIds = game.playerIds;
            const currentIndex = playerIds.indexOf(game.turn);
            const nextIndex = (currentIndex + 1) % playerIds.length;
            return playerIds[nextIndex];
        };
        
        const endHandAndScore = async () => {
            if (!gameState || gameState.status !== 'finished_hand' || gameState.winnerId !== userId) return showModal("❌ Acció Invàlida", "Només el guanyador pot puntuar la mà.");

            try {
                 await runTransaction(db, async (transaction) => {
                    const gameRef = getGameRef(gameId);
                    const gameDoc = await transaction.get(gameRef);
                    const game = gameDoc.data();

                    if (game.status !== 'finished_hand') throw new Error("Estat de partida incorrecte.");

                    let players = game.players;
                    const winnerId = game.winnerId;
                    let bonusMessage = '';
                    
                    const newScores = players.map(p => {
                        let score = 0;
                        if (p.id === winnerId) {
                            let bonus = 0;
                            // Càlcul de bonus
                            if (game.numPlayers > 2) {
                                bonus = calculateRunBonus(p.rack);
                                if (bonus > 0) {
                                    bonusMessage = `${p.name} guanya un bonus de ${bonus} punts per una seqüència!`;
                                }
                            }
                            score = RACKO_POINTS + bonus; 
                        } else {
                            // Puntuació de seqüència per als que no han guanyat
                            score = calculateSequenceScore(p.rack); 
                        }

                        const newTotalScore = p.score + score;
                        return {
                            ...p,
                            rack: Array(NUM_CARDS_IN_RACK).fill(null), // Reinicia el rack
                            score: newTotalScore,
                            scoreHistory: [...p.scoreHistory, score]
                        };
                    });

                    // Comprova si hi ha un guanyador global (>500 punts)
                    const gameWinner = newScores.find(p => p.score >= 500);

                    // Prepara per a la nova mà
                    const maxCardValue = game.maxCardValue;
                    let deck = createAndShuffleDeck(maxCardValue); // Nova baralla
                    const newDiscardPile = [];
                    const nextTurnId = game.winnerId; // El guanyador comença la següent mà 

                    const playersForNextHand = newScores.map(p => {
                        const newRack = [];
                        // Reparteix 10 cartes noves
                        for (let i = 0; i < NUM_CARDS_IN_RACK; i++) {
                            const card = deck.pop(); 
                            if (card !== undefined) { newRack.push(card); }
                        }
                        // Les cartes es reparteixen correctament en ordre aleatori

                        return { ...p, rack: newRack };
                    });
                    
                    if (deck.length > 0) {
                        newDiscardPile.push(deck.pop());
                    }

                    const finalMessages = ["La mà ha acabat. Punts de ronda assignats."];
                    if (bonusMessage) finalMessages.push(bonusMessage);
                    finalMessages.push(`Comença la nova mà ${gameWinner ? '(FINALITZADA)' : ''}.`);


                    transaction.update(gameRef, {
                        status: gameWinner ? 'finished' : 'playing',
                        players: playersForNextHand,
                        deck: deck,
                        discardPile: newDiscardPile,
                        turn: nextTurnId,
                        winnerId: gameWinner ? gameWinner.id : null,
                        messages: arrayUnion(...finalMessages),
                        lastUpdate: Date.now() // Actualitza timestamp
                    });
                });
                
            } catch (error) {
                console.error("Error finalitzant la mà:", error);
                showModal("Error", "No s'ha pogut finalitzar i puntuar la mà.");
            }
        };

        // --- FUNCIONS AUXILIARS I RENDERITZAT ---

        const getMyPlayer = () => gameState?.players.find(p => p.id === userId);
        const isMyTurn = () => gameState?.turn === userId;

        // Funció per mostrar el modal (actualitzada per a confirmació)
        const showModal = (title, message, onConfirm = null) => {
            const modal = document.getElementById('custom-modal');
            const confirmBtn = document.getElementById('modal-confirm-btn');
            const closeBtn = document.getElementById('modal-close-btn');
            
            document.getElementById('modal-title').innerHTML = title;
            document.getElementById('modal-message').innerHTML = message;
            
            if (onConfirm) {
                // Mode de confirmació (per a Host Reset)
                confirmBtn.classList.remove('hidden');
                confirmBtn.onclick = () => {
                    closeModal();
                    onConfirm();
                };
                closeBtn.textContent = "Cancel·lar";
                document.getElementById('modal-title').classList.add('text-red-600');

            } else {
                // Mode d'alerta simple
                confirmBtn.classList.add('hidden');
                closeBtn.textContent = "Entès";
                document.getElementById('modal-title').classList.remove('text-red-600');
            }
            
            modal.classList.remove('hidden');
        };

        const closeModal = () => {
            document.getElementById('custom-modal').classList.add('hidden');
        };

        // Funció per embolicar el deleteGameAndReset amb confirmació
        const confirmReset = () => {
            showModal(
                "⚠️ Confirmació de Reinici", 
                "Estàs segur que vols eliminar permanentment aquesta partida de Firebase? Això farà que **tots els jugadors** tornin al Lobby i es perdrà tot el progrés. Aquesta acció és irreversible.",
                () => deleteGameAndReset(true) // Passar true per indicar reinici manual
            );
        };


        const renderLobby = (message = "") => {
            heldCard = null;
            floatingCardElement.classList.remove('active');

            if (gameId && gameState) {
                 console.warn("Attempted to render Lobby while connected to a game. Skipping.");
                 return;
            }
            
            const savedName = localStorage.getItem('racko_player_name') || '';

            document.getElementById('game-status').innerHTML = `<span class="text-xl font-bold text-gray-800">Sala d'Espera</span>`;
            document.getElementById('game-container').innerHTML = `
                <div class="p-6 bg-white rounded-xl shadow-lg w-full max-w-lg mx-auto">
                    
                    <h3 class="text-xl font-bold mb-4 text-indigo-600">El Teu Nom</h3>
                    <p class="mb-2 text-sm text-gray-700">Com vols que et vegin els altres jugadors (2-15 caràcters)?</p>
                    <input type="text" id="player-name-input" maxlength="15" placeholder="Escriu el teu nom de jugador" value="${savedName}" class="w-full p-3 border-2 border-indigo-300 rounded-lg mb-6 focus:ring-indigo-500 focus:border-indigo-500 text-center text-xl font-semibold">


                    <h3 class="text-2xl font-bold mb-4 text-indigo-600">Unir-se a Partida</h3>
                    <p class="mb-2 text-sm text-gray-700">Introdueix el codi numèric de <span class="font-bold">4 dígits</span> de la partida existent.</p>
                    <input type="text" id="join-game-input" maxlength="4" placeholder="Codi de 4 dígits (Ex: 1234)" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-indigo-500 focus:border-indigo-500 text-center text-xl font-mono tracking-widest">
                    <button id="join-button" onclick="window.gameFunctions.joinGame(document.getElementById('join-game-input').value, document.getElementById('player-name-input').value)" class="w-full py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 mb-8">
                        Unir-se
                    </button>


                    <h3 class="text-2xl font-bold mb-4 text-indigo-600">Crear Partida</h3>
                    <p class="mb-4 text-gray-700">Selecciona el nombre de jugadors per començar. Es generarà un codi de <span class="font-bold text-red-600">4 dígits</span>.</p>
                    <div class="flex justify-around space-x-4">
                        ${[2, 3, 4].map(n => `
                            <button onclick="window.gameFunctions.createGame(${n}, document.getElementById('player-name-input').value)" class="flex-1 py-3 px-4 bg-purple-500 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition duration-300">
                                ${n} Jugadors (Cartes 1-${CARD_DECK_SIZES[n]})
                            </button>
                        `).join('')}
                    </div>
                    <p class="mt-4 text-sm text-red-600 font-semibold">${message}</p>
                    
                    <!-- BOTÓ DE REINICIAR LOBBY -->
                    <div class="mt-6 border-t pt-4">
                        <button onclick="window.gameFunctions.resetLobbyState()" class="w-full py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg shadow-md hover:bg-gray-300 transition duration-300 flex items-center justify-center">
                            <i data-lucide="rotate-ccw" class="w-4 h-4 mr-2"></i> Reiniciar Connexió Local
                        </button>
                    </div>

                </div>
            `;
            document.getElementById('game-active-area').classList.add('hidden');
            document.getElementById('custom-modal').classList.add('hidden'); 
            lucide.createIcons();
        };

        const renderGame = (game) => {
            const container = document.getElementById('game-container');
            
            // 1. CRITICAL CHECK for Data Integrity and Synchronization (WITH LATENCY TOLERANCE)
            if (!game.playerIds.includes(userId)) {
                syncErrorCount++;
                console.warn(`[SYNC WARNING] User ID ${userId} not in playerIds [${game.playerIds}]. Consecutive errors: ${syncErrorCount}.`);
                
                // Donem un marge d'un snapshot per si és un retard de propagació. Si persisteix, desconnectem.
                if (syncErrorCount > 1) {
                    if (gameId) resetLobbyState("Error de Sincronització: El teu ID no es troba a la llista de jugadors. S'ha restablert la connexió.");
                }
                return; // No renderitzem res si hi ha un error de sincronització pendent.
            }
            
            // Si la comprovació té èxit, reiniciem el comptador.
            syncErrorCount = 0;

            const myPlayer = getMyPlayer();

            // 2. Handle Lobby State
            if (game.status === 'lobby') {
                document.getElementById('game-active-area').classList.add('hidden');
                document.getElementById('game-container').innerHTML = ''; 
                renderLobbyContent(game);
                return;
            }
            
            // NOU: Sincronització de Jugador Actiu (Tolerància a la latència)
            if (!myPlayer) {
                // Si l'usuari és a playerIds però myPlayer és null, està esperant que la transacció de startGame es propagui
                document.getElementById('game-active-area').classList.add('hidden');
                document.getElementById('game-container').innerHTML = `
                    <div class="text-center p-8 bg-blue-100 rounded-xl shadow-lg">
                        <i data-lucide="loader-2" class="w-10 h-10 text-blue-600 inline-block animate-spin mb-4"></i>
                        <p class="text-xl font-bold text-blue-700">Sincronitzant dades de jugador...</p>
                        <p class="text-gray-600">La partida ha començat. Espera un moment mentre es reparteixen les cartes.</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }
            
            // 3. Handle Active Game States (Playing, Finished Hand, Finished Game)
            
            document.getElementById('game-active-area').classList.remove('hidden');
            document.getElementById('game-container').innerHTML = '';
            
            // Set floating card state
            if (heldCard) {
                const cardStyle = getCardBackgroundColor(heldCard, game.maxCardValue);
                floatingCardValueElement.setAttribute('style', cardStyle);
                floatingCardValueElement.textContent = heldCard;
                floatingCardElement.classList.add('active');
            } else {
                floatingCardElement.classList.remove('active');
            }

            const isFinishedHand = game.status === 'finished_hand';
            const isFinishedGame = game.status === 'finished';
            const isCurrentTurn = isMyTurn() && !isFinishedHand && !isFinishedGame;

            // Check if current user is the host (creator is the first player in the array)
            const isCreator = game.players.length > 0 && game.players[0].id === userId;

            // Add Host Reset Button (Millora 1)
            const hostResetArea = document.getElementById('host-reset-area');
            if (isCreator && game.status !== 'lobby') {
                hostResetArea.innerHTML = `
                    <button onclick="window.gameFunctions.confirmReset()" class="w-full py-2 px-3 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-300 flex items-center justify-center text-xs whitespace-nowrap">
                        <i data-lucide="alert-triangle" class="w-3 h-3 mr-1"></i> Reiniciar Partida (Host)
                    </button>
                `;
            } else {
                hostResetArea.innerHTML = '';
            }

            // 4. GESTIÓ DE SO i VIBRACIÓ (Nova Funcionalitat de Notificacions)
            
            // A. Trigger Remot (Beep quan altres jugadors cliquen el teu nom)
            const handleBeepTrigger = async () => {
                if (game.beepTrigger && game.beepTrigger.targetId === userId) {
                    const triggerTime = game.beepTrigger.timestamp;
                    
                    // Si el trigger és nou (fins i tot amb latència, 2s és segur)
                    if (Date.now() - triggerTime < 2000) { 
                        playBeep();
                        vibrate([100, 50, 100]); // Vibració específica per alerta remota
                        
                        // Esborra el trigger immediatament per evitar repetir el so en el següent snapshot
                        try {
                            // No actualitzem lastUpdate aquí, ja que no és una acció de joc
                            await updateDoc(getGameRef(gameId), { beepTrigger: null }); 
                        } catch (err) {
                            console.error("Error netejant beepTrigger", err);
                        }
                    }
                }
            };
            handleBeepTrigger();

            // B. Alerta de Torn (Controlat per lastTurnProcessed per sonar una sola vegada)
            if (isCurrentTurn && game.turn !== lastTurnProcessed) {
                playBeep();
                vibrate([300, 100, 300]); // Vibració llarga per torn propi
                lastTurnProcessed = game.turn;
            } else if (!isCurrentTurn && game.turn !== lastTurnProcessed) {
                lastTurnProcessed = game.turn; // Actualitza l'estat per altres jugadors
            }

            // C. Alerta de Victòria/Final (Controlat per lastWinProcessed)
            if ((isFinishedHand || isFinishedGame) && game.status !== lastWinProcessed) {
                playWinMelody();
                vibrate([500, 200, 500]); // Vibració de celebració
                lastWinProcessed = game.status;
            } else if (!isFinishedHand && !isFinishedGame && game.status !== lastWinProcessed) {
                lastWinProcessed = game.status;
            }
            
            // 5. Renderitzat de l'Estat de la Partida i Informació del Jugador (Status Bar)
            let statusText = '';
            let statusColor = '';
            if (isFinishedGame) {
                const finalWinner = game.players.find(p => p.id === game.winnerId);
                statusText = `🏆 JOC FINALITZAT! Guanyador: ${finalWinner?.name || 'Desconegut'} amb ${finalWinner?.score} punts.`;
                statusColor = 'bg-yellow-500 text-gray-900';
            } else if (isFinishedHand) {
                const winnerName = game.players.find(p => p.id === game.winnerId)?.name || 'Algú';
                statusText = `✅ MÀ GUANYADA! ${winnerName} ha fet Rack-O!`;
                statusColor = 'bg-green-500 text-white';
            } else { // Playing
                const turnPlayer = game.players.find(p => p.id === game.turn);
                statusText = `👉 Torn de: ${turnPlayer?.name || 'Desconegut'}`;
                statusColor = isCurrentTurn ? 'bg-green-600 text-white' : 'bg-red-600 text-white';
            }
            document.getElementById('game-status').innerHTML = `<span class="px-4 py-2 rounded-full font-bold ${statusColor} text-sm">${statusText}</span>`;


            // 6. Renderitzat del Tauler de Joc (Deck & Discard)
            const isDeckEmpty = game.deck.length === 0;
            const drawPileElement = document.getElementById('draw-pile');
            let deckContent = '';
            let drawPileClickAction = '';
            let drawPileClickableClass = 'cursor-default';

            if (isDeckEmpty && isCurrentTurn && game.discardPile.length > 1) {
                // Munt buit, és el nostre torn i hi ha cartes suficients per barrejar
                deckContent = `<button onclick="window.gameFunctions.handleReshuffle()" class="w-full h-full bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-bold text-sm p-1 rounded-lg flex flex-col items-center justify-center transition duration-200">
                    <i data-lucide="shuffle" class="w-5 h-5 mb-1"></i> Barrejar Descartades
                </button>`;
                drawPileClickableClass = 'border-yellow-500 ring-2 ring-yellow-300';
                
            } else if (isDeckEmpty) {
                // Munt buit, no és el nostre torn o no hi ha cartes suficients per barrejar
                deckContent = `<div class="flex items-center justify-center w-full h-full text-sm text-gray-500 font-semibold">MUNT BUIT</div>`;
                drawPileClickableClass = 'border-gray-400';
                
            } else {
                // Munt amb cartes: L'acció de clic és la de draw
                drawPileClickAction = `${isCurrentTurn && !heldCard ? 'window.gameFunctions.handleDrawCard(\'draw\')' : ''}`;
                drawPileClickableClass = isCurrentTurn && !heldCard ? 'cursor-pointer hover:border-indigo-600' : 'cursor-default';
                deckContent = `<div class="card-back flex items-center justify-center rounded-lg w-full h-full text-2xl" onclick="${drawPileClickAction}">
                    <i data-lucide="layers"></i>
                </div>`;
            }
            
            drawPileElement.innerHTML = deckContent;
            drawPileElement.className = `w-20 h-32 border-4 rounded-lg transition duration-200 ${drawPileClickableClass}`;
            // S'elimina l'onclick de l'element contenidor si hi ha un botó dins
            drawPileElement.setAttribute('onclick', isDeckEmpty && isCurrentTurn ? '' : drawPileClickAction); 
            document.getElementById('draw-pile-count').textContent = game.deck.length;

            const discardCard = game.discardPile[game.discardPile.length - 1];
            const discardCardStyle = getCardBackgroundColor(discardCard, game.maxCardValue);
            
            // Condició per AGARRAR la carta del discard
            const canDrawFromDiscard = isCurrentTurn && !heldCard && discardCard !== undefined;
            
            // Condició per DESCARTAR la carta agafada (Millora 2)
            const canDiscardHeldCard = isCurrentTurn && heldCard && heldSource === 'draw' && game.status === 'playing';

            let discardClickAction = '';
            let discardClickableClass = '';
            
            if (canDrawFromDiscard) {
                discardClickAction = `window.gameFunctions.handleDrawCard('discard')`;
                discardClickableClass = 'cursor-pointer hover:border-green-600';
            } else if (canDiscardHeldCard) {
                // Si el jugador té una carta i la pot descartar (agafada del munt)
                discardClickAction = `window.gameFunctions.handleDiscardHeldCard()`;
                discardClickableClass = 'cursor-pointer hover:border-red-600 ring-4 ring-red-400';
            } else {
                discardClickableClass = 'cursor-default';
            }

            const discardContent = discardCard !== undefined ? `<div class="card-value w-full h-full flex items-center justify-center text-4xl text-red-600" style="${discardCardStyle}">${discardCard}</div>` : `<div class="flex items-center justify-center w-full h-full text-lg text-gray-500">Buit</div>`;
            
            const discardPileElement = document.getElementById('discard-pile');
            discardPileElement.innerHTML = discardContent;
            discardPileElement.className = `w-20 h-32 border-4 border-gray-400 rounded-lg transition duration-200 ${discardClickableClass}`;
            discardPileElement.setAttribute('onclick', discardClickAction);


            // 7. Botó d'acció/Estat del joc (Actualitzat per reflectir el nou mecanisme de descart)
            let actionHtml = '';
            
            if (isFinishedHand && game.winnerId === userId) {
                actionHtml = `<button onclick="window.gameFunctions.endHandAndScore()" class="w-full py-3 bg-yellow-500 text-gray-900 font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-300 flex items-center justify-center">
                    <i data-lucide="trophy" class="mr-2"></i> Puntuar i Començar Nova Mà
                </button>`;
            } else if (isFinishedHand) {
                const winnerName = game.players.find(p => p.id === game.winnerId)?.name;
                actionHtml = `<p class="text-green-700 font-semibold p-2">Esperant que el guanyador (${winnerName}) punti la mà.</p>`;
            } else if (isFinishedGame) {
                 actionHtml = `<button onclick="window.gameFunctions.resetLobbyState()" class="w-full py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 flex items-center justify-center">
                    <i data-lucide="refresh-cw" class="mr-2"></i> Tornar al Lobby
                </button>`;
            } else if (isCurrentTurn && heldCard) {
                 // Missatge actualitzat segons la font de la carta
                 if (heldSource === 'draw') {
                     actionHtml = `
                        <div class="p-2 border border-blue-200 rounded-lg bg-blue-50">
                            <p class="text-base font-semibold text-blue-700">Has agafat la carta <span class="text-xl text-red-600 font-extrabold">${heldCard}</span> del munt.</p>
                            <p class="text-sm text-blue-800 font-bold mt-1">OPCIONS: 1. Clica la **Pila de Descarts** per descartar, O 2. Clica una ranura per reemplaçar.</p>
                        </div>
                    `;
                 } else { // heldSource === 'discard'
                      actionHtml = `
                        <div class="p-2 border border-blue-200 rounded-lg bg-blue-50">
                            <p class="text-base font-semibold text-blue-700">Has agafat la carta <span class="text-xl text-red-600 font-extrabold">${heldCard}</span> del descart.</p>
                            <p class="text-sm text-red-800 font-bold mt-1">ACCIÓ REQUERIDA: Has de reemplaçar una ranura del teu atril.</p>
                        </div>
                    `;
                 }
            } else if (isCurrentTurn) {
                actionHtml = `<p class="text-lg font-bold text-green-700 p-2 border border-green-200 rounded-lg bg-green-100">
                    <i data-lucide="bell" class="w-5 h-5 inline mr-1 animate-pulse"></i> És el teu torn! Tria del munt o del descart.
                </p>`;
            } else {
                const turnPlayerName = game.players.find(p => p.id === game.turn)?.name || 'Algú';
                actionHtml = `<p class="text-lg font-bold text-orange-700 p-2 border border-orange-200 rounded-lg bg-orange-50">
                    <i data-lucide="loader-2" class="w-5 h-5 inline mr-1 animate-spin"></i> Esperant el torn de ${turnPlayerName}...
                </p>`;
            }
            document.getElementById('action-area').innerHTML = actionHtml;
            
            // 8. Renderitzat de l'Atril (Rack)
            renderRack();

            // 9. Renderitzat de les Puntuacions Global (Amb Clicable Remot)
            document.getElementById('all-players-score').innerHTML = game.players
                .map(p => {
                    const isLocalPlayer = p.id === userId;
                    const isPlayerTurn = p.id === game.turn;
                    const cardClasses = isLocalPlayer ? 'bg-indigo-100 border-indigo-500' : 'bg-gray-100 border-gray-300';
                    
                    // Condicions per fer clic: És el torn del jugador, però NO sóc jo
                    const canRemoteBeep = isPlayerTurn && !isLocalPlayer;
                    
                    const turnRing = isPlayerTurn ? 'ring-4 ring-yellow-500' : ''; 
                    const clickClasses = canRemoteBeep ? 'hover:ring-8 transition duration-150 cursor-pointer' : 'cursor-default';
                    const clickAction = canRemoteBeep ? `onclick="window.gameFunctions.triggerRemoteBeep('${p.id}')"` : '';

                    return `
                        <div class="p-3 rounded-xl border-2 shadow-sm ${cardClasses} ${turnRing} ${clickClasses}" ${clickAction}>
                            <p class="font-bold text-lg flex items-center">
                                ${p.name} ${isLocalPlayer ? ' (Tu)' : ''}
                                ${canRemoteBeep ? '<i data-lucide="volume-2" class="w-4 h-4 ml-2 text-yellow-600"></i>' : (isPlayerTurn ? '<i data-lucide="star" class="w-4 h-4 ml-2 text-yellow-600 fill-yellow-400"></i>' : '')}
                            </p>
                            <p class="text-sm text-gray-800 font-semibold">Puntuació Total: <span class="text-xl text-indigo-700">${p.score}</span></p>
                            <p class="text-xs text-gray-500">Última Puntuació: +${p.scoreHistory[p.scoreHistory.length - 1] || 0}</p>
                        </div>
                    `;
                }).join('');

            // 10. Actualitzar icones
            lucide.createIcons();
        };

        const renderLobbyContent = (game) => {
            const container = document.getElementById('game-container');
            const myPlayer = getMyPlayer();
            
            const creator = game.players[0];
            const isCreator = myPlayer ? myPlayer.id === creator.id : false;
            
            let playerListHtml = game.players.map(p => `<span class="font-semibold ${p.id === userId ? 'text-indigo-600' : 'text-gray-800'}">${p.name} ${p.id === creator.id ? '(Creador)' : ''}</span>`).join(', ');

            const isLobbyFull = game.players.length === game.numPlayers;
            
            let actionHtml = `<div class="p-6 bg-white rounded-xl shadow-lg w-full max-w-lg mx-auto border-t-4 border-blue-500">
                <p class="text-xl font-bold mb-4 text-blue-700">Esperant a la Sala d'Espera</p>
                <p class="text-lg font-bold text-gray-800 mb-2">Codi de Partida (4 Dígits) per Compartir: <span class="text-3xl font-extrabold select-all text-red-600 bg-red-100 p-1 rounded">${gameId}</span></p>
                <p class="text-sm text-gray-700">Jugadors connectats: ${game.players.length} de ${game.numPlayers}.</p>
                <p class="text-sm text-gray-700 mt-2">Jugadors: ${playerListHtml}</p>
                ${isLobbyFull ? 
                    `<p class="text-sm text-green-700 mt-2 font-bold">Lobby complet (${game.players.length}/${game.numPlayers}).</p>` : 
                    `<p class="text-sm text-gray-700 mt-2">Esperant ${game.numPlayers - game.players.length} jugadors més per unir-se...</p>`
                }
                ${isCreator ? `
                    ${isLobbyFull ? `
                        <button onclick="window.gameFunctions.startGame()" class="w-full py-3 mt-4 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-300 flex items-center justify-center">
                            <i data-lucide="play" class="mr-2"></i> Iniciar Partida
                        </button>
                    ` : `
                        <p class="mt-4 text-center text-red-600 font-semibold">Esperant que tots els jugadors (${game.numPlayers}) s'uneixin per iniciar la partida.</p>
                    `}
                    <!-- Botó de Reiniciar (HOST ONLY) -->
                    <button onclick="window.gameFunctions.confirmReset()" class="w-full py-2 mt-4 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-300 flex items-center justify-center">
                        <i data-lucide="alert-triangle" class="w-4 h-4 mr-2"></i> Reiniciar Registre de Partida (Host)
                    </button>
                ` : `<p class="mt-4 text-center text-gray-600">Esperant que el creador de la partida (${creator.name}) l'iniciï quan estigui completa.</p>`}
            </div>`;
            
            container.innerHTML = actionHtml; 
            lucide.createIcons();
            document.getElementById('host-reset-area').innerHTML = ''; // Ensure host button is hidden in lobby debug panel
        };

        const renderRack = () => {
            if (!gameState) return;
            const myPlayer = getMyPlayer();
            if (!myPlayer) return; 

            const rackElement = document.getElementById('my-rack');
            const isCurrentTurn = isMyTurn() && gameState.status === 'playing';
            const maxCardValue = gameState.maxCardValue;
            
            let sequenceBroken = false; // Flag per rastrejar la ruptura de la seqüència

            rackElement.innerHTML = myPlayer.rack.map((card, index) => {
                const isPlayableSlot = isCurrentTurn && heldCard && card !== null && gameState.status === 'playing';
                const slotNumber = index + 1; 

                // Lògica de color per al número de la ranura
                let isSlotCorrect = false;
                if (!sequenceBroken) {
                    // La condició de correcte només es comprova si la seqüència no s'ha trencat encara
                    isSlotCorrect = (index === 0 && card !== null) || 
                                      (index > 0 && card !== null && myPlayer.rack[index - 1] !== null && card > myPlayer.rack[index - 1]);
                    
                    if (!isSlotCorrect) {
                        sequenceBroken = true; // Un cop es trenca, es manté trencada
                    }
                }
                const slotNumberColorClass = isSlotCorrect ? 'text-green-600' : 'text-red-600';


                let cardHtml;
                if (card === null) {
                    cardHtml = `<div class="card-slot not-playable">
                        ${slotNumber}
                    </div>`;
                } else {
                    const cardStyle = getCardBackgroundColor(card, maxCardValue);
                    cardHtml = `<div class="card-slot has-card ${isPlayableSlot ? 'can-replace' : ''} transition-all duration-300" 
                                onclick="${isPlayableSlot ? `window.gameFunctions.handleReplaceCard(${index})` : ''}">
                        <div class="card-value text-3xl" style="${cardStyle}">${card}</div>
                    </div>`;
                }

                return `
                    <div class="flex items-center space-x-2">
                        <span class="text-sm font-bold w-6 text-right ${slotNumberColorClass}">${slotNumber}:</span>
                        <div class="flex-1">
                            ${cardHtml}
                        </div>
                    </div>
                `;
            }).join('');
        };

        // Exportar funcions de joc a la finestra per a l'HTML
        window.gameFunctions = {
            createGame: (num, name) => createGame(num, name),
            joinGame: (id, name) => joinGame(id, name),
            startGame,
            handleDrawCard,
            handleReplaceCard,
            handleDiscardHeldCard, 
            endHandAndScore,
            resetLobbyState: () => resetLobbyState(), 
            triggerRemoteBeep, 
            deleteGameAndReset, 
            confirmReset, 
            closeModal,
            handleReshuffle 
        };

        // Inici de l'aplicació
        initFirebase();
    </script>
</body>
</html>